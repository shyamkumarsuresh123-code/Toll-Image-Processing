<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toy Car Lane Counter</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h1 { color: #333; }

        #status {
            margin-bottom: 10px;
            font-weight: bold;
            color: #d9534f;
        }

        /* Container to stack canvas over video */
        #container {
            position: relative;
            box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            width: 640px;
            height: 480px;
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        .controls {
            margin-top: 15px;
            background: white;
            padding: 15px 30px;
            border-radius: 50px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #count-display {
            font-size: 2rem;
            font-weight: bold;
            color: #28a745; /* Green */
        }
    </style>
</head>
<body>

    <h1>ðŸš— Toy Car Lane Counter</h1>
    <div id="status">Loading Model... Please wait.</div>

    <div id="container">
        <video id="video" width="640" height="480" autoplay muted playsinline></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>

    <div class="controls">
        Lane Count: <span id="count-display">0</span>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status');
        const countDisplay = document.getElementById('count-display');

        // --- CONFIGURATION ---
        // Define the "Lane" (The rectangular frame)
        // Values are: x, y, width, height
        const LANE_RECT = { x: 170, y: 100, w: 300, h: 280 }; 
        
        let model = null;

        // 1. Load Model & Setup Camera
        async function setup() {
            try {
                // Load the COCO-SSD model (pre-trained object detection)
                model = await cocoSsd.load();
                statusText.innerText = "Model Loaded. Starting Camera...";
                statusText.style.color = "#f0ad4e";

                // Access Webcam
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;

                // Wait for video to load data
                video.onloadeddata = () => {
                    statusText.innerText = "Running Detection...";
                    statusText.style.color = "#28a745";
                    detectFrame();
                };
            } catch (err) {
                statusText.innerText = "Error: " + err.message;
                console.error(err);
            }
        }

        // 2. Detection Loop
        async function detectFrame() {
            // Draw the current video frame to the canvas (optional, but good for syncing)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get predictions from the model
            // We look for objects in the video element
            const predictions = await model.detect(video);

            // Draw the "Lane" Frame
            drawLane();

            let currentLaneCount = 0;

            // Process predictions
            predictions.forEach(prediction => {
                // prediction.class gives the object type (e.g., 'car', 'truck')
                // prediction.bbox gives [x, y, width, height]

                // Filter: We only care about cars or trucks (common for toy cars)
                const validTypes = ['car', 'truck', 'bus'];
                if (validTypes.includes(prediction.class)) {
                    
                    const [x, y, width, height] = prediction.bbox;

                    // Check if the object is fully inside the lane
                    const isInside = isFullyInside(x, y, width, height, LANE_RECT);

                    if (isInside) {
                        currentLaneCount++;
                        // Draw Green Box (Counted)
                        drawBox(x, y, width, height, prediction.class, 'green');
                    } else {
                        // Draw Red Box (Not Counted / Partial)
                        drawBox(x, y, width, height, prediction.class, 'red');
                    }
                }
            });

            // Update the display text
            // "No negative values" is handled because count starts at 0 every frame
            countDisplay.innerText = currentLaneCount;

            // Loop
            requestAnimationFrame(detectFrame);
        }

        // --- HELPER FUNCTIONS ---

        // Draw the static Lane Frame
        function drawLane() {
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]); // Dashed line for effect
            ctx.strokeRect(LANE_RECT.x, LANE_RECT.y, LANE_RECT.w, LANE_RECT.h);
            ctx.setLineDash([]); // Reset dash
            
            // Label the lane
            ctx.fillStyle = 'blue';
            ctx.font = '16px Arial';
            ctx.fillText("LANE AREA", LANE_RECT.x + 5, LANE_RECT.y + 20);
        }

        // Check if Box A (Object) is FULLY inside Box B (Lane)
        function isFullyInside(objX, objY, objW, objH, lane) {
            const objRight = objX + objW;
            const objBottom = objY + objH;
            const laneRight = lane.x + lane.w;
            const laneBottom = lane.y + lane.h;

            return (
                objX >= lane.x &&           // Left edge is inside
                objY >= lane.y &&           // Top edge is inside
                objRight <= laneRight &&    // Right edge is inside
                objBottom <= laneBottom     // Bottom edge is inside
            );
        }

        // Draw object bounding box
        function drawBox(x, y, w, h, label, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);

            ctx.fillStyle = color;
            ctx.fillRect(x, y - 20, w, 20); // Label background

            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText(label, x + 5, y - 5);
        }

        // Start the app
        setup();

    </script>
</body>
</html>
